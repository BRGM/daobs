<?xml version="1.0" encoding="UTF-8"?>
<!-- Configures the cm Context-->

<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:cm="http://camel.apache.org/schema/spring"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
       http://camel.apache.org/schema/spring
        http://camel.apache.org/schema/spring/camel-spring.xsd">

  <!-- bridge spring property placeholder with cm -->
  <!-- you must NOT use the <context:property-placeholder at the same time,
  only this bridge bean -->
  <bean id="bridgePropertyPlaceholder"
        class="org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer">
    <property name="location" value="config.properties"/>
  </bean>

  <bean id="cswHarvester" class="org.daobs.harvester.CswHarvester">
    <property name="maxRecords" value="${csw.get.records.max.records}"/>
  </bean>
  <bean id="harvesterDetailsAgg" class="org.daobs.harvester.HarvesterDetailsAggregate">
  </bean>

  <cm:errorHandler id="loggingErrorHandler"
                      type="LoggingErrorHandler"
                      logName="daobs.harvesters.csw"
                      level="DEBUG"/>

  <cm:camelContext xmlns:ogc="http://www.opengis.net/ogc"
                   xmlns:csw="http://www.opengis.net/cat/csw/2.0.2"
      errorHandlerRef="loggingErrorHandler">

    <cm:onException>
      <cm:exception>org.apache.camel.component.http4.HttpOperationFailedException</cm:exception>
      <cm:continued>
        <cm:constant>true</cm:constant>
      </cm:continued>
      <cm:log message="Oops, something went wrong: $simple{exception.message}" loggingLevel="ERROR"/>
      <cm:log message="$simple{exception.stacktrace}" loggingLevel="ERROR"/>
    </cm:onException>


    <cm:route>
      <!--<cm:from uri="timer://start?repeatCount=1"/>-->
      <cm:from uri="file:src/main/resources/?fileName=config-harvesters.xml&amp;noop=true&amp;consumer.delay=100000"/>
      <cm:log message="Loading configuration ..."/>
      <cm:convertBodyTo type="org.w3c.dom.Document"/>
      <cm:split>
        <cm:xpath>/harvesters/harvester</cm:xpath>
        <cm:to uri="log:org.daobs.harvester.csw?showBody=true"/>
        <cm:setHeader headerName="harvesterUrl">
          <cm:xpath resultType="java.lang.String">harvester/url</cm:xpath>
        </cm:setHeader>
        <cm:setHeader headerName="harvesterTerritory">
          <cm:xpath resultType="java.lang.String">harvester/territory</cm:xpath>
        </cm:setHeader>
        <cm:setHeader headerName="harvesterName">
          <cm:xpath resultType="java.lang.String">harvester/name</cm:xpath>
        </cm:setHeader>
        <cm:choice>
          <cm:when>
            <cm:xpath>harvester/filter/ogc:Filter</cm:xpath>
            <cm:setHeader headerName="harvesterFilter">
              <cm:xpath resultType="org.w3c.dom.Document">harvester/filter/ogc:Filter</cm:xpath>
            </cm:setHeader>
          </cm:when>
          <cm:otherwise>
            <cm:setHeader headerName="harvesterFilter">
              <cm:simple resultType="org.w3c.dom.Document">
                <![CDATA[<Filter xmlns="http://www.opengis.net/ogc"/>]]>
              </cm:simple>
            </cm:setHeader>
          </cm:otherwise>
        </cm:choice>
        <cm:setHeader headerName="harvesterBeginTime">
          <cm:simple>${date:now:yyyyMMdd'T'HH':'mm':'SS}</cm:simple>
        </cm:setHeader>
        <cm:log message="Harvesting node $simple{header.harvesterName} ($simple{header.harvesterTerritory}) at $simple{header.harvesterURL}"/>
        <cm:log message="CSW filter is $simple{header.harvesterFilter}"/>
        <cm:log message="Starting at $simple{header.harvesterBeginTime}"/>

        <cm:to uri="direct:harvestNode"/>
      </cm:split>
    </cm:route>

    <cm:route startupOrder="2">
      <cm:description>
        Send a GetRecords request with no filter (cf. csw-get-records-hits.xml)
        in order to retrieve the max number of records to harvest.
        The numberOfRecordsMatched attribute of the response is
        retrieved.
      </cm:description>
      <!-- Start once.
      TODO: Should be cron based.
      http://camel.apache.org/quartz2.html
      -->
      <cm:from uri="direct:harvestNode"/>
      <cm:bean ref="cswHarvester" method="initialize"/>
      <!--<cm:from uri="timer://start?repeatCount=1"/>-->
      <cm:log message="Harvesting from $simple{header.harvesterUrl} ..."/>
      <!-- Add logger for time http://camel.apache.org/eventnotifier-to-log-details-about-all-sent-exchanges.html -->
      <cm:setHeader headerName="camelHttpMethod">
        <cm:constant>POST</cm:constant>
      </cm:setHeader>
      <cm:setHeader headerName="Content-Type">
        <cm:constant>application/xml</cm:constant>
      </cm:setHeader>
      <cm:setBody>
        <cm:simple>bean:cswHarvester?method=generateGetRecordsHitsQuery</cm:simple>
      </cm:setBody>
     <!-- <cm:setBody>
        <cm:simple>resource:classpath:csw-get-records-hits.xml</cm:simple>
      </cm:setBody>-->
      <!--<cm:choice>
        <cm:when>
          <cm:simple>$header.harvesterUrl startsWith "https"</cm:simple>
          <cm:recipientList>
            <cm:simple>http4://$simple{header.harvesterUrl}.replaceAll("https://", "")</cm:simple>
          </cm:recipientList>
        </cm:when>
        <cm:otherwise>
          <cm:recipientList>
            <cm:simple>http4://$simple{header.harvesterUrl}.replaceAll("http://", "")</cm:simple>
          </cm:recipientList>
        </cm:otherwise>
      </cm:choice>-->
      <!--<cm:recipientList>
        <cm:simple>http4://$simple{header.harvesterUrl}</cm:simple>
      </cm:recipientList>-->
      <cm:setHeader headerName="Exchange.HTTP_URI">
        <cm:simple>${header.harvesterUrl}</cm:simple>
      </cm:setHeader>
      <cm:to uri="http4://csw.server.url"/>
      <cm:convertBodyTo type="org.w3c.dom.Document"/>
      <cm:choice>
        <cm:when>
          <!-- If records found, next route is direct:cswGetRecords. -->
          <cm:xpath>/csw:GetRecordsResponse/
            csw:SearchResults[@numberOfRecordsMatched > 0]</cm:xpath>
          <cm:setHeader headerName="numberOfRecordsMatched">
            <cm:xpath resultType="java.lang.String">
              /csw:GetRecordsResponse/csw:SearchResults/@numberOfRecordsMatched
            </cm:xpath>
          </cm:setHeader>
          <cm:log message="$simple{header.numberOfRecordsMatched} record(s) to harvest."/>
          <cm:to uri="bean:cswHarvester?method=setNumberOfRecords(${header.harvesterUrl}, ${header.numberOfRecordsMatched})"/>
          <cm:to uri="direct:cswGetRecords"/>
        </cm:when>
        <cm:when>
          <cm:xpath>/csw:GetRecordsResponse/csw:SearchResults[@numberOfRecordsMatched = 0]</cm:xpath>
          <cm:log message="No record found."/>
        </cm:when>
        <cm:otherwise>
          <cm:log message="Probably an exception occurred. Check CSW response: ${body}"/>
        </cm:otherwise>
      </cm:choice>
    </cm:route>


    <cm:route startupOrder="0" shutdownRunningTask="CompleteAllTasks">
      <cm:description>Based on the total number of records
      to be harvested, retrieve records per page and index
      them in SOLR. All records are removed from the indexed
      when the task starts.

      TODO: Improve update strategy.
      </cm:description>
      <cm:from uri="direct:cswGetRecords"/>
      <cm:log message="Harvesting records ..."/>
      <!--<cm:to uri="direct:indexDeleteDocuments"/>-->
      <cm:split parallelProcessing="true">
        <cm:method bean="cswHarvester" method="getPages"/>
        <cm:log message="Processing page: $simple{property.CamelSplitIndex} / $simple{bean:cswHarvester?method=getNumberOfPages}"/>
        <cm:log message="GetRecords request ..."/>
        <cm:setHeader headerName="cmHttpMethod">
          <cm:constant>POST</cm:constant>
        </cm:setHeader>
        <cm:setHeader headerName="Content-Type">
          <cm:constant>application/xml</cm:constant>
        </cm:setHeader>
        <cm:setBody>
          <cm:simple>bean:cswHarvester?method=generateGetRecordsQuery</cm:simple>
        </cm:setBody>
        <cm:setHeader headerName="Exchange.HTTP_URI">
          <cm:simple>${header.harvesterUrl}</cm:simple>
        </cm:setHeader>
        <cm:to uri="http4://csw.server.url"/>
        <!--<cm:to uri="xslt:metadata-iso19139.xsl?saxon=true&amp;output=DOM"/>-->
        <cm:log message="GetRecords response received. Indexing records ..."/>
        <cm:setHeader headerName="camelHttpMethod">
          <cm:constant>POST</cm:constant>
        </cm:setHeader>
        <cm:setHeader headerName="Content-Type">
          <cm:constant>application/xml</cm:constant>
        </cm:setHeader>
        <cm:setBody>
          <cm:simple>${body}</cm:simple>
        </cm:setBody>
        <cm:convertBodyTo type="org.w3c.dom.Document"/>
        <!-- TODO: Add CSW request to the document -->
        <cm:bean ref="harvesterDetailsAgg"
                 method="doTransform($simple{body}, $simple{header.harvesterUrl}, $simple{header.harvesterTerritory})"/>
        <cm:multicast stopOnException="false"
                         parallelProcessing="false">
          <!-- Backup response as XML file-->
          <cm:to uri="file:csw/get-records-response/?fileName=$simple{header.harvesterTerritory}/$simple{date:now:yyyyMMdd}-$simple{property.CamelSplitIndex}.xml&amp;charset=utf-8"/>
          <!-- Index in Solr -->
          <!--<cm:to uri="http4://{{solr.server.url}}/update/xslt?commit=true&amp;tr=metadata-iso19139.xsl&amp;throwExceptionOnFailure=false" />-->
          <cm:to uri="direct:indexDocuments"/>
        </cm:multicast>


      </cm:split>
    </cm:route>


    <cm:route>
      <cm:description>
        Index records in Solr and report any errors.
      </cm:description>
      <cm:from uri="direct:indexDocuments"/>
      <cm:setHeader headerName="Exchange.HTTP_URI">
        <cm:simple>http://{{solr.server.url}}/update/xslt?commit=true&amp;tr=metadata-iso19139.xsl&amp;</cm:simple>
      </cm:setHeader>
      <cm:to uri="http4://solr.server.url?throwExceptionOnFailure=false" />
      <!-- Camel Solr component can't be used to set the
      xslt transformation to use in the request handler. -->
      <!--<cm:setHeader headerName="SolrOperation">-->
      <!--<cm:constant>INSERT</cm:constant>-->
      <!--</cm:setHeader>-->
      <!--<cm:to uri="solr://localhost:8983/solr/data/update/xslt?commit=true&amp;tr=metadata-iso19139.xsl'"/>-->
      <cm:convertBodyTo type="org.w3c.dom.Document"/>
      <cm:to uri="log:org.daobs.harvester.csw?showBody=true"/>
      <cm:choice>
        <cm:when>
          <!-- If records found, next route is direct:cswGetRecords. -->
          <cm:xpath>/response/lst/int[@name = 'status' and text() = '400']</cm:xpath>
          <cm:setHeader headerName="indexingError">
            <cm:xpath resultType="java.lang.String">
              /response/lst/str[@name = 'msg']/text()
            </cm:xpath>
          </cm:setHeader>
          <cm:log message="Oops, error while indexing records of page #$simple{property.CamelSplitIndex}: $simple{header.indexingError}." loggingLevel="ERROR"/>
        </cm:when>
        <cm:otherwise>
          <cm:setHeader headerName="indexingTime">
            <cm:xpath resultType="java.lang.String">
              /response/lst/int[@name = 'QTime']/text()
            </cm:xpath>
          </cm:setHeader>
          <cm:log message="Records indexed in $simple{header.indexingTime}ms." loggingLevel="INFO"/>
        </cm:otherwise>
      </cm:choice>
    </cm:route>

    <cm:route>
      <cm:description>
        Delete all records from the index.

        TODO: Should only delete record for this harvester only
      </cm:description>
      <cm:from uri="direct:indexDeleteDocuments"/>
      <cm:setHeader headerName="SolrOperation">
        <cm:constant>DELETE_BY_QUERY</cm:constant>
      </cm:setHeader>
      <cm:setBody>
        <cm:simple>{{solr.delete.filter}}</cm:simple>
      </cm:setBody>
      <cm:to uri="solr://{{solr.server.url}}"/>
    </cm:route>
  </cm:camelContext>
</beans>
